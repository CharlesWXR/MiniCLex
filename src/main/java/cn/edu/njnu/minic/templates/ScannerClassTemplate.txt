package ${package_name};

import cn.edu.njnu.minic.lex.State;
import cn.edu.njnu.minic.exception.ScannerException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

${support_classes}

/*
    This file is automatically generated.
    This class requires the support of enum 'State' to describe the target MFA.
    Requires the hand written functions to drive such class.
*/

public class WordScanner {
    private static List<State> start = new ArrayList<State>();
    private static List<State> end = new ArrayList<State>();

    private List<State> present = new ArrayList<State>();
    private StringBuffer stringBuffer = new StringBuffer();
    private Map<State, Integer> matchedStates = new HashMap<State, Integer>();
    private State lastMatchedState;

    static {
${init_static_slot}
    }

    public WordScanner() {
        init();
    }

    // After a successful match, this function should be invoked.
    public void init() {
        this.present.clear();
        this.present.addAll(this.start);
        this.stringBuffer.setLength(0);
        matchedStates.clear();
        this.lastMatchedState = null;
    }

    // Test whether can have probability to match a longer result
    public boolean hasNext() {
        return !this.present.isEmpty();
    }

    public String next(char ch) throws Exception {
        if (this.present.size() == 0)
            throw new ScannerException(ScannerException.NoMatch);

        List<State> newState = new ArrayList<State>();
        this.stringBuffer.append(ch);
        for (State s : this.present) {
            State temp = s.next(ch);
            if (temp == States.Fail)
                continue;

            if (this.end.contains(temp)) {
                this.matchedStates.put(temp, this.stringBuffer.length());
                this.lastMatchedState = temp;
            }
            newState.add(temp);
        }

        if (newState.size() == 0) {
            if (this.lastMatchedState == null || !this.matchedStates.containsKey(this.lastMatchedState))
                throw new ScannerException(ScannerException.NoMatch);

            int max_len = this.matchedStates.get(this.lastMatchedState);
            if (max_len == this.stringBuffer.length())
                return "";
            else
                return this.stringBuffer.substring(max_len);
        }

        this.present = newState;
        return null;
    }

    public Object execute() throws Exception {
        if (this.lastMatchedState == null)
            throw new ScannerException(ScannerException.NoMatch);

        return this.lastMatchedState.execute(
            this.stringBuffer.substring(0, this.matchedStates.get(this.lastMatchedState))
        );
    }

    public String getUnMatched() {
        if (this.lastMatchedState == null)
            return this.stringBuffer.toString();

        return this.stringBuffer.substring(this.matchedStates.get(this.lastMatchedState));
    }

    public boolean hasMatched() {
        return this.lastMatchedState != null;
    }
}